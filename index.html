<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plants vs. Zombies - IA Agents</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="1636" height="1332"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const tintCanvas = document.createElement('canvas');
    const tintCtx = tintCanvas.getContext('2d');

    // Configuración de la Grid
    const GRID_START_X = 90;
    const GRID_START_Y = 280;
    const GRID_END_X = 1577;
    const GRID_END_Y = 1260;
    const COLS = 9;
    const ROWS = 5;
    const CELL_WIDTH = (GRID_END_X - GRID_START_X) / COLS;
    const CELL_HEIGHT = (GRID_END_Y - GRID_START_Y) / ROWS;
    
    // Variables Globales del Motor
    let frames = 0;
    let isPaused = false;
    let isDebug = false;
    let mouseX = 0;
    let mouseY = 0;
    let lastEatSoundFrame = 0;
    
    // --- [INICIO_ZONA_VARIABLES_CONTROL_4.3] ---
    // Variables para el Drag & Drop de Zombis (Tarea 4.3)
    let draggedZombie = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    // --- [FIN_ZONA_VARIABLES_CONTROL_4.3] ---
    
    // Arrays de Entidades
    let suns = [];
    let plants = [];
    let zombies = [];
    let peas = [];
    let particles = [];
    let floatingTexts = [];
    let lawnmowers = []; // Se actualizará en Lote 5
    let pendingZombies = []; // Para el director de hordas
    
    // Sistema de Hordas
    const LEVEL_CONFIG = { totalZombies: 40, horde1Threshold: 20, horde2Threshold: 38, baseSpawnRate: 350 };
    let zombiesSpawned = 0;

    // Recursos
    const imageSources = {
        background: 'recursos/background.png',
        barraSemillas: 'recursos/barra de semillas.png',
        sol: 'recursos/sol.png', 
        pala: 'recursos/pala.png',
        envoltura: 'recursos/envoltura de semilla.png',
        semillaGirasol: 'recursos/semilla de girasol.png',
        semillaGuisante: 'recursos/semilla de lanza guisantes.png',
        semillaNuez: 'recursos/semilla de nuez.png',
        cortacesped: 'recursos/cortacesped.png',
        guisante: 'recursos/guisante.png',
        progressBar: 'recursos/barra de progreso/barra.png',
        progressFlag: 'recursos/barra de progreso/bandera.png',
        progressZombieHead: 'recursos/barra de progreso/cabeza de zombi.png'
    };

    // Frames de animación del sol (carga dinámica)
    const sunFrames = [];
    const SUN_TOTAL_FRAMES = 192;
    let sunFramesLoaded = 0;

    const images = {};
    let imagesLoaded = 0;
    const totalImages = Object.keys(imageSources).length;

    // Datos de Semillas
    const seeds = [
        { name: 'girasol', imageKey: 'semillaGirasol', cost: 50, cooldown: 450, timer: 0 },
        { name: 'guisante', imageKey: 'semillaGuisante', cost: 100, cooldown: 450, timer: 0 },
        { name: 'nuez', imageKey: 'semillaNuez', cost: 50, cooldown: 1800, timer: 0 }
    ];

    // Estado del juego UI
    let sunAmount = 200; 
    const sunRange = { min: 10, max: 200 };
    const seedRange = { min: 200, max: 1110 };
    const shovelRange = { min: 1110, max: 1237 };
    
    let selectedSeed = null;
    let isShovelActive = false;
    let gridState = Array.from({ length: COLS }, () => Array(ROWS).fill(null));

    // ==========================================
    // 1. CLASES DE ENTIDADES
    // ==========================================
    
    // --- [INICIO_ZONA_CLASE_SUN_1.1] ---
    class Sun {
        constructor(x, y, isFalling = true) {
            this.x = x;
            this.y = y;
            this.isFalling = isFalling;
            this.finalY = isFalling ? y + Math.random() * 300 + 200 : y;
            this.fallSpeed = 1.875;
            this.isCollecting = false;
            this.targetX = 105;
            this.targetY = 100;
            this.frame = Math.floor(Math.random() * SUN_TOTAL_FRAMES);
            this.animSpeed = 2;
            this.width = 0;
            this.height = 0;
            this.markedForDeletion = false;
            // --- [INICIO_ZONA_LIFETIMER_SOL_4.1] ---
            this.hasCompletedCycle = false;
            // --- [FIN_ZONA_LIFETIMER_SOL_4.1] ---
        }

        update() {
            // --- [INICIO_ZONA_UPDATE_SOL_4.1] ---
            if (!this.isCollecting && !this.isFalling && !this.hasCompletedCycle) {
                const prevFrame = this.frame;
                if (frames % this.animSpeed === 0) {
                    const nextFrame = (this.frame + 1) % SUN_TOTAL_FRAMES;
                    if (nextFrame === 0 && prevFrame === SUN_TOTAL_FRAMES - 1) {
                        this.hasCompletedCycle = true;
                        this.markedForDeletion = true;
                    }
                }
            }
            // --- [FIN_ZONA_UPDATE_SOL_4.1] ---

            if (frames % this.animSpeed === 0) {
                this.frame = (this.frame + 1) % SUN_TOTAL_FRAMES;
            }

            if (this.isCollecting) {
                this.x += (this.targetX - this.x) * 0.15;
                this.y += (this.targetY - this.y) * 0.15;

                if (Math.abs(this.x - this.targetX) < 5 && Math.abs(this.y - this.targetY) < 5) {
                    sunAmount += 25;
                    floatingTexts.push(new FloatingText('+25', this.targetX, this.targetY, '#FFD700'));
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(this.targetX, this.targetY, '#FFD700', 'spark'));
                        particles.push(new Particle(this.targetX, this.targetY, '#FFFF00', 'circle'));
                    }
                    this.markedForDeletion = true;
                }
            } else if (this.isFalling) {
                if (this.y < this.finalY) {
                    this.y += this.fallSpeed;
                } else {
                    this.y = this.finalY;
                    this.isFalling = false;
                }
            }
        }

        draw() {
            if (sunFrames[this.frame]) {
                const img = sunFrames[this.frame];
                this.width = img.naturalWidth * 0.5;
                this.height = img.naturalHeight * 0.5;
                const drawX = this.x - this.width / 2;
                const drawY = this.y - this.height / 2;
                ctx.drawImage(img, drawX, drawY, this.width, this.height);
            }
        }

        isClicked(mx, my) {
            const halfW = this.width / 2;
            const halfH = this.height / 2;
            return mx >= this.x - halfW && mx <= this.x + halfW &&
                   my >= this.y - halfH && my <= this.y + halfH;
        }
    }

    class FloatingText {
        constructor(text, x, y, color = '#FFD700') {
            this.text = text;
            this.x = x;
            this.y = y;
            this.color = color;
            this.alpha = 1;
            this.velocityY = -2;
            this.markedForDeletion = false;
        }

        update() {
            this.y += this.velocityY;
            this.alpha -= 0.02;
            if (this.alpha <= 0) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = this.color;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, type = 'circle') {
            this.x = x;
            this.y = y;
            this.color = color;
            this.type = type;
            this.size = Math.random() * 6 + 3;
            this.velocityX = (Math.random() - 0.5) * 8;
            this.velocityY = (Math.random() - 0.5) * 8 - 2;
            this.gravity = 0.15;
            this.alpha = 1;
            this.markedForDeletion = false;
        }

        update() {
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.velocityY += this.gravity;
            this.alpha -= 0.03;
            if (this.alpha <= 0) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            if (this.type === 'spark') {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.size);
                ctx.lineTo(this.x + this.size * 0.3, this.y);
                ctx.lineTo(this.x, this.y + this.size);
                ctx.lineTo(this.x - this.size * 0.3, this.y);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
    }

    function spawnSun(x, y, isFalling = true) {
        suns.push(new Sun(x, y, isFalling));
    }

    function loadSunFrames() {
        for (let i = 0; i < SUN_TOTAL_FRAMES; i++) {
            const img = new Image();
            const frameNum = String(i).padStart(3, '0');
            img.src = `recursos/sol/sol${frameNum}.png`;
            img.onload = () => sunFramesLoaded++;
            sunFrames.push(img);
        }
    }
    // --- [FIN_ZONA_CLASE_SUN_1.1] ---

    // --- [INICIO_ZONA_CLASE_PEA_2.2] ---
    class Pea {
        constructor(x, y, row) {
            this.x = x;
            this.y = y;
            this.row = row;
            this.speed = 6.25; 
            this.damage = 20;
            this.width = 0;
            this.height = 0;
            this.markedForDeletion = false;
        }

        update() {
            this.x += this.speed;
            if (this.x > canvas.width) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            if (images.guisante) {
                const img = images.guisante;
                this.width = img.width;
                this.height = img.height;
                ctx.drawImage(img, this.x - this.width / 2, this.y - this.height / 2);
            }
        }
    }

    function spawnPea(x, y, row) {
        peas.push(new Pea(x, y, row));
    }
    // --- [FIN_ZONA_CLASE_PEA_2.2] ---

    // --- [INICIO_ZONA_CLASE_LAWNMOWER_5.2] ---
    class Lawnmower {
        // IA inyectará la lógica y clase del cortacésped aquí en Lote 5
    }
    // --- [FIN_ZONA_CLASE_LAWNMOWER_5.2] ---

    // --- [INICIO_ZONA_CLASE_ZOMBIE_2.1] ---
    const zombieAnimations = {
        walk: { frames: [], totalFrames: 46, scale: 0.35, path: 'recursos/zombie caminata/zombie caminata', ext: '.png', padZeros: 2 },
        eat: { frames: [], totalFrames: 36, scale: 0.35, path: 'recursos/zombie come/zombie come', ext: '.png', padZeros: 2 },
        die: { frames: [], totalFrames: 50, scale: 0.35, path: 'recursos/zombie perdurbador cae/zombie perdurbador cae', ext: '.png', padZeros: 2 }
    };
    let zombieAnimsLoaded = 0;

    class Zombie {
        constructor(row = null) {
            this.row = row !== null ? row : Math.floor(Math.random() * ROWS);
            this.x = GRID_END_X + 100;
            this.y = GRID_START_Y + (this.row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            this.state = 'walk';
            this.speed = 0.6;
            this.frame = 0;
            this.animSpeed = 2;
            this.hp = 200;
            this.maxHp = 200;
            this.damage = 50;
            this.attackCooldown = 15; 
            this.attackTimer = 0;
            this.flashTimer = 0;
            this.fadeTimer = 0;
            this.targetPlant = null;
            this.markedForDeletion = false;
            
            // --- [INICIO_ZONA_ZOMBIE_ORGANICO_5.3] ---
            // Desincronización: Velocidades aleatorias para comportamiento orgánico
            const speedVariation = Math.random() * 0.1 - 0.05; // ±0.05
            this.speed += speedVariation;
            
            // Variación en velocidad de animación
            const animSpeedVariation = Math.random() > 0.5 ? 1 : 0; // -1, 0, o +1 frames
            this.animSpeed += animSpeedVariation;
            if (this.animSpeed < 1) this.animSpeed = 1; // Evitar valores menores a 1
            // --- [FIN_ZONA_ZOMBIE_ORGANICO_5.3] ---
        }

        update() {
            if (frames % this.animSpeed === 0) {
                const animData = zombieAnimations[this.state];
                if (animData) {
                    if (this.state === 'die' && this.frame >= animData.totalFrames - 1) {
                        this.frame = animData.totalFrames - 1;
                    } else {
                        this.frame = (this.frame + 1) % animData.totalFrames;
                    }
                }
            }

            if (this.flashTimer > 0) this.flashTimer--;

            if (this.state === 'walk') {
                let closestPlant = null;
                let minDistance = Infinity;

                for (const plant of plants) {
                    if (plant.row === this.row && plant.x < this.x) {
                        const dist = this.x - plant.x;
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestPlant = plant;
                        }
                    }
                }

                if (closestPlant && minDistance < 60) {
                    this.state = 'eat';
                    this.targetPlant = closestPlant;
                    this.frame = 0;
                } else {
                    this.x -= this.speed;
                }
            } else if (this.state === 'eat') {
                if (this.targetPlant && !this.targetPlant.markedForDeletion) {
                    this.attackTimer++;
                    if (this.attackTimer >= this.attackCooldown) {
                        this.targetPlant.takeDamage(this.damage);
                        this.attackTimer = 0;
                        
                        if (frames - lastEatSoundFrame > 15) {
                            const eatSound = Math.floor(Math.random() * 3) + 1;
                            const audio = new Audio(`recursos/sonidos/Zombi come ${eatSound}.wav`);
                            audio.volume = 0.4;
                            audio.play().catch(e => {}); 
                            lastEatSoundFrame = frames;
                        }
                    }
                } else {
                    this.state = 'walk';
                    this.targetPlant = null;
                    this.attackTimer = 0;
                    this.frame = 0;
                }
            } else if (this.state === 'die') {
                const dieAnimData = zombieAnimations.die;
                const isLastDieFrame = dieAnimData && this.frame >= dieAnimData.totalFrames - 1;

                if (isLastDieFrame) {
                    this.fadeTimer++;
                    if (this.fadeTimer >= 45) {
                        this.markedForDeletion = true;
                    }
                }
            }

            if (this.hp <= 0 && this.state !== 'die') {
                this.state = 'die';
                this.frame = 0;
                this.fadeTimer = 0;
                
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(this.x, this.y, '#663399', 'circle'));
                    particles.push(new Particle(this.x, this.y, '#4B0082', 'spark'));
                }
            }
        }

        draw() {
            const animData = zombieAnimations[this.state];
            if (animData && animData.frames[this.frame]) {
                const img = animData.frames[this.frame];
                const scale = animData.scale;
                const width = img.naturalWidth * scale;
                const height = img.naturalHeight * scale;
                const drawX = this.x - width / 2;
                const drawY = this.y - height / 2;

                ctx.save();
                
                const dieAnimData = zombieAnimations.die;
                const isLastDieFrame = dieAnimData && this.frame >= dieAnimData.totalFrames - 1;
                if (this.state === 'die' && isLastDieFrame) {
                    ctx.globalAlpha = 1 - (this.fadeTimer / 45);
                }
                
                ctx.drawImage(img, drawX, drawY, width, height);

                if (this.flashTimer > 0) {
                    tintCanvas.width = width;
                    tintCanvas.height = height;
                    tintCtx.drawImage(img, 0, 0, width, height);
                    tintCtx.globalCompositeOperation = 'source-in';
                    tintCtx.fillStyle = 'white';
                    tintCtx.fillRect(0, 0, width, height);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(tintCanvas, drawX, drawY);
                    ctx.restore();
                }
                
                ctx.restore();
            }
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.flashTimer = 4;
            floatingTexts.push(new FloatingText(`-${amount}`, this.x, this.y - 30, '#FF0000'));
        }
    }

    function loadZombieAnimations() {
        for (const animName in zombieAnimations) {
            const animData = zombieAnimations[animName];
            for (let i = 0; i < animData.totalFrames; i++) {
                const img = new Image();
                const pad = (animData.padZeros !== undefined) ? animData.padZeros : 2;
                const frameNum = String(i).padStart(pad, '0');
                img.src = `${animData.path}${frameNum}${animData.ext}`;
                img.onload = () => zombieAnimsLoaded++;
                animData.frames.push(img);
            }
        }
    }
    // --- [FIN_ZONA_CLASE_ZOMBIE_2.1] ---

    // --- [INICIO_ZONA_CLASE_PLANT_1.3] ---
    const plantAnimations = {
        girasol: { frames: [], totalFrames: 58, scale: 0.3, path: 'recursos/girasol perturbador/girasol perturbador', ext: '.png', padZeros: 2 },
        guisante: { frames: [], totalFrames: 31, scale: 0.35, path: 'recursos/lg reposo perturbador/lg reposo perturbador', ext: '.png', padZeros: 2 },
        lg_ataque: { frames: [], totalFrames: 46, scale: 0.35, path: 'recursos/lanza guisantes ataque/lanza guisantes ataque', ext: '.png', padZeros: 2 },
        nuez: { frames: [], totalFrames: 1, scale: 0.3, path: 'recursos/nuez/nuez', ext: '.png', padZeros: 0 }
    };
    let plantAnimsLoaded = 0;

    class Plant {
        constructor(type, col, row) {
            this.type = type;
            this.col = col;
            this.row = row;
            this.x = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
            this.y = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            this.frame = 0;
            this.animSpeed = 2;
            this.hp = 300;
            if (type === 'nuez') this.hp = 4000;
            this.maxHp = this.hp;
            this.flashTimer = 0;
            this.markedForDeletion = false;
            this.currentAnim = type; 
            this.hasFiredThisLoop = false; 
            this.sunTimer = 0;
            
            // --- [INICIO_ZONA_PETACEREZA_5.1] ---
            // IA inyectará configuraciones específicas de la cereza aquí
            // --- [FIN_ZONA_PETACEREZA_5.1] ---
        }

        update() {
            // Lógica de Girasol
            if (this.type === 'girasol') {
                this.sunTimer++;
                if (this.sunTimer >= 700) { 
                    spawnSun(this.x, this.y, false);
                    this.sunTimer = 0;
                }
            }

            // Lógica especial para lanzaguisantes
            if (this.type === 'guisante') {
                let hasZombieInRow = false;
                for (const zombie of zombies) {
                    if (zombie.row === this.row && zombie.x > this.x) {
                        hasZombieInRow = true;
                        break;
                    }
                }

                if (hasZombieInRow && this.currentAnim !== 'lg_ataque') {
                    this.currentAnim = 'lg_ataque';
                    this.frame = 0;
                    this.hasFiredThisLoop = false;
                } else if (!hasZombieInRow && this.currentAnim === 'lg_ataque') {
                    this.currentAnim = 'guisante';
                    this.frame = 0;
                }
            }

            // Animación
            if (frames % this.animSpeed === 0) {
                const animData = plantAnimations[this.currentAnim];
                if (animData) {
                    const prevFrame = this.frame;
                    this.frame = (this.frame + 1) % animData.totalFrames;

                    if (this.currentAnim === 'lg_ataque' && this.frame === 27 && !this.hasFiredThisLoop) {
                        const peaY = this.y - 40;
                        spawnPea(this.x + 30, peaY, this.row);
                        
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(this.x + 30, peaY, '#FFFF00', 'spark'));
                            particles.push(new Particle(this.x + 30, peaY, '#ADFF2F', 'spark'));
                        }
                        this.hasFiredThisLoop = true;
                    }

                    if (this.frame < prevFrame) {
                        this.hasFiredThisLoop = false;
                    }
                    
                    // --- [INICIO_ZONA_EXPLOSION_PETACEREZA_5.1] ---
                    // IA inyectará lógica de explosión y screen shake aquí
                    // --- [FIN_ZONA_EXPLOSION_PETACEREZA_5.1] ---
                }
            }

            if (this.flashTimer > 0) this.flashTimer--;

            if (this.hp <= 0) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            const animData = plantAnimations[this.currentAnim];
            if (animData && animData.frames[this.frame]) {
                const img = animData.frames[this.frame];
                const scale = animData.scale;
                const width = img.naturalWidth * scale;
                const height = img.naturalHeight * scale;
                const drawX = this.x - width / 2;
                const drawY = this.y - height / 2;

                ctx.save();
                ctx.drawImage(img, drawX, drawY, width, height);

                if (this.flashTimer > 0) {
                    tintCanvas.width = width;
                    tintCanvas.height = height;
                    tintCtx.drawImage(img, 0, 0, width, height);
                    tintCtx.globalCompositeOperation = 'source-in';
                    tintCtx.fillStyle = 'white';
                    tintCtx.fillRect(0, 0, width, height);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(tintCanvas, drawX, drawY);
                    ctx.restore();
                }
                ctx.restore();
            }
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.flashTimer = 4;
            floatingTexts.push(new FloatingText(`-${amount}`, this.x, this.y - 30, '#FF0000'));
        }
    }

    function loadPlantAnimations() {
        for (const plantType in plantAnimations) {
            const animData = plantAnimations[plantType];
            for (let i = 0; i < animData.totalFrames; i++) {
                const img = new Image();
                const pad = (animData.padZeros !== undefined) ? animData.padZeros : 2;
                const frameNum = String(i).padStart(pad, '0');
                img.src = `${animData.path}${frameNum}${animData.ext}`;
                img.onload = () => plantAnimsLoaded++;
                animData.frames.push(img);
            }
        }
    }
    // --- [FIN_ZONA_CLASE_PLANT_1.3] ---

    // ==========================================
    // 2. INPUTS Y EVENTOS
    // ==========================================
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        // --- [INICIO_ZONA_DRAG_MOVE_4.3] ---
        if (isDebug && draggedZombie) {
            draggedZombie.x = mouseX + dragOffsetX;
            draggedZombie.y = mouseY + dragOffsetY;
        }
        // --- [FIN_ZONA_DRAG_MOVE_4.3] ---
    });

    canvas.addEventListener('mousedown', (e) => {
        if (isPaused) return;
        if (e.button !== 0) return; 

        // --- [INICIO_ZONA_CLICK_SOLES_1.1] ---
        // Soles tienen prioridad sobre herramientas de debug
        for (const sun of suns) {
            if (!sun.isCollecting && sun.isClicked(mouseX, mouseY)) {
                sun.isCollecting = true;
                new Audio('recursos/sonidos/Recoger sol 1.wav').play();
                
                // --- [INICIO_ZONA_PARTICULAS_SOL_4.1] ---
                for (let i = 0; i < 12; i++) {
                    particles.push(new Particle(sun.x, sun.y, '#FFD700', 'spark'));
                    particles.push(new Particle(sun.x, sun.y, '#FFFFFF', 'circle'));
                }
                // --- [FIN_ZONA_PARTICULAS_SOL_4.1] ---
                break; // Si se clickea un sol, no hacer nada más (opcional, o quitar break para permitir debug click through)
            }
        }
        // --- [FIN_ZONA_CLICK_SOLES_1.1] ---

        // --- [INICIO_ZONA_EDIT_SOLES_4.3] ---
        if (isDebug && mouseX >= sunRange.min && mouseX <= sunRange.max && mouseY >= 0 && mouseY <= 200) {
            const newValue = prompt('Ingresa la nueva cantidad de soles:', sunAmount);
            if (newValue !== null && !isNaN(newValue)) {
                sunAmount = parseInt(newValue, 10);
            }
            return;
        }
        // --- [FIN_ZONA_EDIT_SOLES_4.3] ---
        
        // --- [INICIO_ZONA_DRAG_START_4.3] ---
        if (isDebug) {
            for (const zombie of zombies) {
                const animData = zombieAnimations[zombie.state];
                if (animData && animData.frames[zombie.frame]) {
                    const img = animData.frames[zombie.frame];
                    const scale = animData.scale;
                    const width = img.naturalWidth * scale;
                    const height = img.naturalHeight * scale;
                    
                    if (mouseX >= zombie.x - width / 2 && mouseX <= zombie.x + width / 2 &&
                        mouseY >= zombie.y - height / 2 && mouseY <= zombie.y + height / 2) {
                        draggedZombie = zombie;
                        dragOffsetX = zombie.x - mouseX;
                        dragOffsetY = zombie.y - mouseY;
                        return;
                    }
                }
            }
        }
        // --- [FIN_ZONA_DRAG_START_4.3] ---

        // --- [INICIO_ZONA_DRAG_START_4.3] ---
        if (mouseY >= 20 && mouseY <= 160) {
            if (mouseX >= shovelRange.min && mouseX < shovelRange.max) {
                isShovelActive = !isShovelActive;
                selectedSeed = null; 
            }
        }
        
        if (isShovelActive && mouseX >= GRID_START_X && mouseX < GRID_END_X &&
            mouseY >= GRID_START_Y && mouseY < GRID_END_Y) {
            
            const col = Math.floor((mouseX - GRID_START_X) / CELL_WIDTH);
            const row = Math.floor((mouseY - GRID_START_Y) / CELL_HEIGHT);
            
            if (gridState[col][row]) {
                const plant = gridState[col][row];
                plant.markedForDeletion = true;
                new Audio('recursos/sonidos/Escarbar.wav').play();
                
                const cellCenterX = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
                const cellCenterY = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
                for (let i = 0; i < 12; i++) {
                    particles.push(new Particle(cellCenterX, cellCenterY, '#8B4513', 'circle'));
                    particles.push(new Particle(cellCenterX, cellCenterY, '#A0522D', 'circle'));
                }
                isShovelActive = false;
            }
        }
        // --- [FIN_ZONA_CLICK_PALA_3.1] ---

        // --- [INICIO_ZONA_CLICK_PLANTAR_1.3] ---
        if (selectedSeed && mouseX >= GRID_START_X && mouseX < GRID_END_X && 
            mouseY >= GRID_START_Y && mouseY < GRID_END_Y) {
            
            const col = Math.floor((mouseX - GRID_START_X) / CELL_WIDTH);
            const row = Math.floor((mouseY - GRID_START_Y) / CELL_HEIGHT);
            
            if (!gridState[col][row]) {
                if (isDebug || (sunAmount >= selectedSeed.cost && selectedSeed.timer <= 0)) {
                    if (!isDebug) sunAmount -= selectedSeed.cost;
                    
                    const plant = new Plant(selectedSeed.name, col, row);
                    plants.push(plant);
                    gridState[col][row] = plant;
                    
                    if (!isDebug) selectedSeed.timer = selectedSeed.cooldown;
                    
                    const cellCenterX = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
                    const cellCenterY = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
                    floatingTexts.push(new FloatingText(`-${selectedSeed.cost}`, cellCenterX, cellCenterY - 50, '#FF0000'));
                    
                    new Audio('recursos/sonidos/Plantar.wav').play();
                    
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(cellCenterX, cellCenterY, '#8B4513', 'circle'));
                        particles.push(new Particle(cellCenterX, cellCenterY, '#A0522D', 'circle'));
                    }
                    selectedSeed = null;
                }
            }
        }
        // --- [FIN_ZONA_CLICK_PLANTAR_1.3] ---

        // --- [INICIO_ZONA_CLICK_SEMILLAS_1.2] ---
        if (mouseY >= 20 && mouseY <= 160) {
            if (mouseX >= seedRange.min && mouseX < seedRange.max) {
                let currentSeedX = seedRange.min;
                const envolturaWidth = images.envoltura ? images.envoltura.width : 0;
                
                for (let i = 0; i < seeds.length; i++) {
                    const seedEndX = currentSeedX + envolturaWidth;
                    if (mouseX >= currentSeedX && mouseX < seedEndX) {
                        const canAfford = isDebug || sunAmount >= seeds[i].cost;
                        const isReady = isDebug || seeds[i].timer <= 0;
                        
                        if (canAfford && isReady) {
                            selectedSeed = seeds[i];
                            isShovelActive = false;
                        }
                        break;
                    }
                    currentSeedX += envolturaWidth;
                }
            }
        }
        // --- [FIN_ZONA_CLICK_SEMILLAS_1.2] ---
    });

    // --- [INICIO_ZONA_DRAG_END_4.3] ---
    canvas.addEventListener('mouseup', (e) => {
        if (draggedZombie) {
            // Reposicionar zombi en Y (Snap to row)
            const row = Math.round((draggedZombie.y - GRID_START_Y - (CELL_HEIGHT / 2)) / CELL_HEIGHT);
            // Asegurar que esté dentro de los límites de filas
            const clampedRow = Math.max(0, Math.min(row, ROWS - 1));
            
            draggedZombie.row = clampedRow;
            draggedZombie.y = GRID_START_Y + (clampedRow * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            
            draggedZombie = null;
        }
    });
    // --- [FIN_ZONA_DRAG_END_4.3] ---

    // --- [INICIO_ZONA_CLICK_DERECHO_3.1] ---
    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault(); 
        selectedSeed = null;
        isShovelActive = false;
    });
    // --- [FIN_ZONA_CLICK_DERECHO_3.1] ---

    window.addEventListener('keydown', (e) => {
        // --- [INICIO_ZONA_TECLAS_DEBUG_3.2] ---
        if (e.key === 'p' || e.key === 'P') isPaused = !isPaused;
        if (e.key === 'd' || e.key === 'D') isDebug = !isDebug;
        // --- [FIN_ZONA_TECLAS_DEBUG_3.2] ---
    });

    // ==========================================
    // 3. INICIALIZACIÓN
    // ==========================================
    function init() {
        // Inicialización temporal, la IA la modificará en Tarea 5.2
        for (let i = 0; i < ROWS; i++) {
            lawnmowers.push({
                x: -70,
                y: GRID_START_Y + (i * CELL_HEIGHT) + (CELL_HEIGHT / 2) - 30,
                row: i,
                active: false
            });
        }
        loadImages();
    }

    function loadImages() {
        loadSunFrames();
        loadPlantAnimations();
        loadZombieAnimations();
        for (let key in imageSources) {
            const img = new Image();
            img.src = imageSources[key];
            img.onload = () => {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('Todas las imágenes cargadas. Iniciando juego.');
                    initGame();
                }
            };
            img.onerror = (e) => console.error('Error cargando imagen:', key, e);
            images[key] = img;
        }
    }

    function initGame() {
        // === [TRIGGER_TAREA_1.1] ===
        // === [FIN_TRIGGER_TAREA_1.1] ===

        // === [TRIGGER_TAREA_1.3] ===
        // === [FIN_TRIGGER_TAREA_1.3] ===

        // === [TRIGGER_TAREA_2.1] ===
        // === [FIN_TRIGGER_TAREA_2.1] ===

        // === [TRIGGER_TAREA_2.2] ===
        // 3 filas de zombis (5 por fila) con un espacio de celda entre filas
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < 3; col++) {
                const z = new Zombie(row);
                z.x = GRID_END_X + 50 + (col * CELL_WIDTH * 2);
                zombies.push(z);
            }
        }
        // === [FIN_TRIGGER_TAREA_2.2] ===

        // === [TRIGGER_TAREA_3.2] ===
        // === [FIN_TRIGGER_TAREA_3.2] ===

        // === [TRIGGER_TAREA_4.1] ===
        setTimeout(() => {
            spawnSun(400, 200, true);
        }, 1000);
        // === [FIN_TRIGGER_TAREA_4.1] ===

        // === [TRIGGER_TAREA_4.2] ===
        // Dar soles suficientes para probar visualmente los 3 estados de las semillas
        sunAmount = 150;
        // Semillas inician sin cooldown
        seeds.forEach(seed => seed.timer = 0);
        // === [FIN_TRIGGER_TAREA_4.2] ===

        // === [TRIGGER_TAREA_4.3] ===
        // === [FIN_TRIGGER_TAREA_4.3] ===
        
        // === [TRIGGER_TAREA_5.1] ===
        // === [FIN_TRIGGER_TAREA_5.1] ===

        // === [TRIGGER_TAREA_5.2] ===
        // === [FIN_TRIGGER_TAREA_5.2] ===

        requestAnimationFrame(gameLoop);
    }

    // ==========================================
    // 4. LÓGICA PRINCIPAL (UPDATE)
    // ==========================================
    function checkCollisions() {
        // --- [INICIO_ZONA_COLISIONES_2.3] ---
        for (const pea of peas) {
            if (pea.markedForDeletion) continue;
            for (const z of zombies) {
                if (z.markedForDeletion || z.state === 'die') continue;
                if (pea.row !== z.row) continue;
                
                const distance = Math.abs(pea.x - z.x);
                if (distance < 40) {
                    z.takeDamage(20);
                    pea.markedForDeletion = true;
                    new Audio('recursos/sonidos/Colision de guisante.mp3').play();
                    
                    for (let i = 0; i < 6; i++) {
                        particles.push(new Particle(pea.x, pea.y, '#33FF33', 'circle'));
                        particles.push(new Particle(pea.x, pea.y, '#00CC00', 'spark'));
                    }
                    break;
                }
            }
        }
        // --- [FIN_ZONA_COLISIONES_2.3] ---
    }

    function updateGame() {
        // --- [INICIO_ZONA_UPDATE_ENTIDADES] ---
        suns.forEach(sun => sun.update());
        suns = suns.filter(sun => !sun.markedForDeletion);

        floatingTexts.forEach(ft => ft.update());
        floatingTexts = floatingTexts.filter(ft => !ft.markedForDeletion);

        particles.forEach(p => p.update());
        particles = particles.filter(p => !p.markedForDeletion);

        plants.forEach(plant => plant.update());
        plants = plants.filter(plant => {
            if (plant.markedForDeletion) {
                gridState[plant.col][plant.row] = null;
                return false;
            }
            return true;
        });

        seeds.forEach(seed => {
            if (seed.timer > 0) seed.timer--;
        });

        zombies.forEach(zombie => zombie.update());
        zombies = zombies.filter(zombie => !zombie.markedForDeletion);

        peas.forEach(pea => pea.update());
        peas = peas.filter(pea => !pea.markedForDeletion);
        // --- [FIN_ZONA_UPDATE_ENTIDADES] ---

        // === [TRIGGER_TAREA_3.3] ===
        if (frames % 30 === 0) {
            zombiesSpawned++;
            if (zombiesSpawned > LEVEL_CONFIG.totalZombies) {
                zombiesSpawned = LEVEL_CONFIG.totalZombies;
            }
        }
        
        if (frames % 180 === 0 && zombies.length > 0) {
            if (Math.random() < 0.7) {
                const groanNum = Math.floor(Math.random() * 5) + 1;
                const audio = new Audio(`recursos/sonidos/Gruñido de zombi ${groanNum}.wav`);
                audio.volume = 0.2;
                audio.play();
            }
        }
        // === [FIN_TRIGGER_TAREA_3.3] ===

        // --- [INICIO_ZONA_SPAWN_SOLES_4.1] ---
        if (frames % 300 === 0) {
            const randomX = GRID_START_X + Math.random() * (GRID_END_X - GRID_START_X);
            const randomFinalY = GRID_START_Y + Math.random() * (GRID_END_Y - GRID_START_Y);
            spawnSun(randomX, 200, true);
        }
        // --- [FIN_ZONA_SPAWN_SOLES_4.1] ---

        // --- [INICIO_ZONA_SPAWN_NORMAL_2.1] ---
        // --- [FIN_ZONA_SPAWN_NORMAL_2.1] ---

        // --- [INICIO_ZONA_SPAWN_HORDAS_4.2] ---
        // IA inyectará lógica del director de hordas aquí
        // --- [FIN_ZONA_SPAWN_HORDAS_4.2] ---

        checkCollisions();

        // --- [INICIO_ZONA_CONDICIONES_FINALES_5.3] ---
        // Condición de Derrota: Zombi cruza la línea sin cortacésped
        for (const zombie of zombies) {
            if (zombie.x < -50 && zombie.state !== 'die') {
                // Verificar si hay cortacésped disponible en esta fila
                const mowerInRow = lawnmowers.find(m => m.row === zombie.row && !m.active);
                
                if (!mowerInRow) {
                    // Game Over
                    isPaused = true;
                    
                    // Dibujar mensaje de derrota (se dibujará en el siguiente frame)
                    setTimeout(() => {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        ctx.font = 'bold 80px Arial';
                        ctx.fillStyle = '#FF0000';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 8;
                        ctx.strokeText('¡LOS ZOMBIS SE COMIERON TUS CEREBROS!', canvas.width / 2, canvas.height / 2);
                        ctx.fillText('¡LOS ZOMBIS SE COMIERON TUS CEREBROS!', canvas.width / 2, canvas.height / 2);
                        ctx.restore();
                    }, 100);
                    
                    break;
                }
            }
        }
        
        // Condición de Victoria: Todos los zombis derrotados
        const noLivingZombies = zombies.every(z => z.state === 'die' || z.markedForDeletion) || zombies.length === 0;
        const noPendingZombies = pendingZombies.length === 0;
        const hordesCompleted = zombiesSpawned >= LEVEL_CONFIG.totalZombies;
        
        if (noLivingZombies && noPendingZombies && hordesCompleted && !isPaused) {
            // Victoria
            isPaused = true;
            
            // Dibujar mensaje de victoria (se dibujará en el siguiente frame)
            setTimeout(() => {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.font = 'bold 100px Arial';
                ctx.fillStyle = '#00FF00';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 10;
                ctx.strokeText('¡NIVEL COMPLETADO!', canvas.width / 2, canvas.height / 2);
                ctx.fillText('¡NIVEL COMPLETADO!', canvas.width / 2, canvas.height / 2);
                ctx.restore();
            }, 100);
        }
        // --- [FIN_ZONA_CONDICIONES_FINALES_5.3] ---

        frames++;
    }

    // ==========================================
    // 5. RENDERIZADO PRINCIPAL (DRAW)
    // ==========================================
    function gameLoop() {
        if (!isPaused) updateGame();
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (images.background) ctx.drawImage(images.background, 0, 0);

        if (isDebug) drawGrid();

        // --- [INICIO_ZONA_DRAW_ENTIDADES] ---
        plants.forEach(plant => plant.draw());
        zombies.forEach(zombie => zombie.draw());
        peas.forEach(pea => pea.draw());
        suns.forEach(sun => sun.draw());
        particles.forEach(p => p.draw());
        floatingTexts.forEach(ft => ft.draw());
        // --- [FIN_ZONA_DRAW_ENTIDADES] ---

        drawLawnmowers();

        // --- [INICIO_ZONA_DRAW_FANTASMA_1.2] ---
        if (selectedSeed && mouseX >= GRID_START_X && mouseX < GRID_END_X && 
            mouseY >= GRID_START_Y && mouseY < GRID_END_Y) {
            
            const col = Math.floor((mouseX - GRID_START_X) / CELL_WIDTH);
            const row = Math.floor((mouseY - GRID_START_Y) / CELL_HEIGHT);
            const cellCenterX = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
            const cellCenterY = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            
            const animData = plantAnimations[selectedSeed.name];
            if (animData && animData.frames.length > 0 && animData.frames[0]) {
                const plantImg = animData.frames[0];
                const scale = animData.scale;
                const width = plantImg.naturalWidth * scale;
                const height = plantImg.naturalHeight * scale;

                ctx.save();
                ctx.globalAlpha = 0.5;
                const drawX = cellCenterX - (width / 2);
                const drawY = cellCenterY - (height / 2);
                ctx.drawImage(plantImg, drawX, drawY, width, height);
                ctx.restore();
            }
        }
        // --- [FIN_ZONA_DRAW_FANTASMA_1.2] ---

        drawUI();

        // Preview de planta siguiendo el cursor (encima de la UI)
        if (selectedSeed) {
            const animData = plantAnimations[selectedSeed.name];
            if (animData && animData.frames.length > 0 && animData.frames[0]) {
                const plantImg = animData.frames[0];
                const scale = animData.scale;
                const width = plantImg.naturalWidth * scale;
                const height = plantImg.naturalHeight * scale;

                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.drawImage(plantImg, mouseX - width / 2, mouseY - height / 2, width, height);
                ctx.restore();
            }
        }

        // --- [INICIO_ZONA_DRAW_COOLDOWN_3.1] ---
        let currentSeedX = seedRange.min;
        
        seeds.forEach(seed => {
            const envolturaImg = images.envoltura;
            
            // --- [INICIO_ZONA_UI_SEMILLAS_4.2] ---
            // En Debug Mode, no dibujar cooldown visual
            if (!isDebug && envolturaImg && seed.timer > 0) {
                const seedWidth = envolturaImg.width;
                const seedHeight = envolturaImg.height;
                const cooldownRatio = seed.timer / seed.cooldown;
                const overlayHeight = seedHeight * cooldownRatio;

                // Cooldown se revela de abajo hacia arriba
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(
                    currentSeedX,
                    20,
                    seedWidth,
                    overlayHeight
                );
            }
            // --- [FIN_ZONA_UI_SEMILLAS_4.2] ---
            currentSeedX += envolturaImg ? envolturaImg.width : 0;
        });
        // --- [FIN_ZONA_DRAW_COOLDOWN_3.1] ---

        // --- [INICIO_ZONA_DRAW_PALA_PREVIEW_3.1] ---
        if (isShovelActive && images.pala) {
            ctx.save();
            const scale = 1.1;
            const palaWidth = images.pala.width * scale;
            const palaHeight = images.pala.height * scale;
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            
            ctx.globalAlpha = 0.85;
            ctx.drawImage(images.pala, mouseX - palaWidth / 2, mouseY - palaHeight / 2, palaWidth, palaHeight);
            ctx.restore();
        }
        // --- [FIN_ZONA_DRAW_PALA_PREVIEW_3.1] ---

        drawProgressBar();

        if (isDebug) drawDebug();

        // --- [INICIO_ZONA_DRAW_PAUSA_4.3] ---
        if (isPaused) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 120px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 8;
            ctx.strokeText('PAUSADO', canvas.width / 2, canvas.height / 2);
            ctx.fillText('PAUSADO', canvas.width / 2, canvas.height / 2);
            ctx.restore();
        }
        // --- [FIN_ZONA_DRAW_PAUSA_4.3] ---

        requestAnimationFrame(gameLoop);
    }

    function drawGrid() {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i <= COLS; i++) {
            const x = GRID_START_X + (i * CELL_WIDTH);
            ctx.moveTo(x, GRID_START_Y);
            ctx.lineTo(x, GRID_END_Y);
        }
        for (let i = 0; i <= ROWS; i++) {
            const y = GRID_START_Y + (i * CELL_HEIGHT);
            ctx.moveTo(GRID_START_X, y);
            ctx.lineTo(GRID_END_X, y);
        }
        ctx.stroke();
    }

    function drawUI() {
        if (images.barraSemillas) ctx.drawImage(images.barraSemillas, 10, 10);

        const sunCenterX = (sunRange.min + sunRange.max) / 2;
        if (images.sol) {
            const solX = sunCenterX - (images.sol.width / 2);
            ctx.drawImage(images.sol, solX, 0);
        }
        
        ctx.font = '40px Arial';
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.fillText(sunAmount, sunCenterX, 195);

        const shovelCenterX = (shovelRange.min + shovelRange.max) / 2;
        if (images.pala) {
            const palaX = shovelCenterX - (images.pala.width / 2);
            ctx.drawImage(images.pala, palaX, 0);
        }

        let currentSeedX = seedRange.min;
        
        seeds.forEach(seed => {
            const envolturaImg = images.envoltura;
            const plantaImg = images[seed.imageKey];
            
            if (envolturaImg && plantaImg) {
                const seedWidth = envolturaImg.width;
                const isReady = isDebug || seed.timer <= 0;
                const canAfford = isDebug || sunAmount >= seed.cost;

                ctx.save();

                // --- [INICIO_ZONA_GLOW_SEMILLAS_4.2] ---
                if (isReady && canAfford) {
                    // Resplandor sutil si la planta está lista y hay soles
                    ctx.shadowColor = 'rgba(255, 255, 200, 0.7)';
                    ctx.shadowBlur = 15;
                }
                // --- [FIN_ZONA_GLOW_SEMILLAS_4.2] ---

                ctx.drawImage(envolturaImg, currentSeedX, 20);

                // --- [INICIO_ZONA_ALPHA_SEMILLAS_4.2] ---
                if (!canAfford) {
                    // Semitransparente si no hay soles suficientes (se suma al cooldown)
                    ctx.globalAlpha = 0.5;
                }
                // --- [FIN_ZONA_ALPHA_SEMILLAS_4.2] ---

                const plantaX = currentSeedX + (seedWidth / 2) - (plantaImg.width / 2);
                ctx.drawImage(plantaImg, plantaX, 0);

                ctx.restore();
                
                ctx.font = '25px Arial';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                const textX = currentSeedX + (seedWidth / 2);
                ctx.fillText(seed.cost, textX, 183);

                currentSeedX += seedWidth;
            }
        });
    }

    function drawProgressBar() {
        const barImg = images.progressBar;
        const flagImg = images.progressFlag;
        const zombieHeadImg = images.progressZombieHead;
        
        if (!barImg || !flagImg || !zombieHeadImg) return;
        
        const barX = canvas.width - barImg.width - 20;
        const barY = canvas.height - barImg.height - 20;
        
        ctx.drawImage(barImg, barX, barY);
        const progress = Math.min(zombiesSpawned / LEVEL_CONFIG.totalZombies, 1);
        const barStartX = barX + barImg.width - 20; 
        const barEndX = barX + 40; 
        
        const flagX = barEndX - (flagImg.width / 2);
        const flagY = barY - flagImg.height + 20;
        ctx.drawImage(flagImg, flagX, flagY);
        
        const headScale = 0.6;
        const headWidth = zombieHeadImg.naturalWidth * headScale;
        const headHeight = zombieHeadImg.naturalHeight * headScale;

        const zombieHeadX = barStartX - (barStartX - barEndX) * progress - (headWidth / 2);
        const zombieHeadY = barY + (barImg.height / 2) - (headHeight / 2);
        
        ctx.save();
        ctx.fillStyle = '#00FF00';
        ctx.globalAlpha = 0.6;
        const trailHeight = barImg.height * 0.4; 
        const trailY = barY + (barImg.height - trailHeight) / 2;
        const headCenterX = zombieHeadX + headWidth / 2;
        ctx.fillRect(headCenterX, trailY, barStartX - headCenterX, trailHeight);
        ctx.restore();

        ctx.drawImage(zombieHeadImg, zombieHeadX, zombieHeadY, headWidth, headHeight);
    }

    function drawLawnmowers() {
        lawnmowers.forEach(mower => {
            if (images.cortacesped) {
                const drawY = GRID_START_Y + (mower.row * CELL_HEIGHT) + (CELL_HEIGHT/2) - (images.cortacesped.height / 2);
                ctx.drawImage(images.cortacesped, mower.x, drawY);
            }
        });
    }

    // --- [INICIO_ZONA_FUNC_DEBUG_3.2] ---
    let lastFrameTime = performance.now();
    let fps = 0;
    let fpsUpdateCounter = 0;

    function drawDebug() {
        fpsUpdateCounter++;
        if (fpsUpdateCounter >= 30) {
            const now = performance.now();
            fps = Math.round(1000 / ((now - lastFrameTime) / fpsUpdateCounter));
            lastFrameTime = now;
            fpsUpdateCounter = 0;
        }

        ctx.save();
        ctx.font = 'bold 24px Arial';
        ctx.fillStyle = '#00FF00';
        ctx.textAlign = 'left';
        ctx.fillText(`FPS: ${fps}`, 20, canvas.height - 20);
        ctx.fillText('DEBUG MODE (D: toggle, P: pause)', 20, canvas.height - 50);
        if (isPaused) {
            ctx.fillStyle = '#FF0000';
            ctx.fillText('PAUSED', 20, canvas.height - 80);
        }
        ctx.restore();

        // --- [INICIO_ZONA_HITBOX_DEBUG_4.3] ---
        // Hitboxes eliminadas para dejar solo la grid
        // --- [FIN_ZONA_HITBOX_DEBUG_4.3] ---
    }
    // --- [FIN_ZONA_FUNC_DEBUG_3.2] ---

    init();

</script>
</body>
</html>