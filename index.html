<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ Horror Remake</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1636" height="1332"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configuración
        const CONFIG = {
            grid: {
                startX: 90,
                startY: 280,
                endX: 1577,
                endY: 1260,
                cols: 9,
                rows: 5
            },
            ui: {
                seedBarPos: { x: 10, y: 10 },
                sunRange: { start: 10, end: 200 },
                seedRange: { start: 200, end: 1110 },
                shovelRange: { start: 1110, end: 1237 },
                text: {
                    sunY: 195,
                    sunSize: 40,
                    seedCostY: 183,
                    seedCostSize: 25
                },
                positions: {
                    sunIconY: 0,
                    shovelY: 0,
                    seedPacketY: 20,
                    seedImageY: 0
                }
            },
            lawnmower: {
                x: -70
            }
        };

        // Estado del juego
        const state = {
            suns: 50,
            seeds: [
                { name: 'girasol', image: 'semilla de girasol', cost: 50 },
                { name: 'lanzaguisantes', image: 'semilla de lanza guisantes', cost: 100 },
                { name: 'nuez', image: 'semilla de nuez', cost: 50 },
                { name: 'cereza', image: 'semilla de cereza', cost: 150 }
            ]
        };

        // Variables globales del juego
        let frames = 0;
        const entities = {
            suns: [],
            peas: [],
            lawnmowers: []
        };

        // Recursos
        const resources = {
            images: {},
            toLoad: [
                { id: 'background', src: 'recursos/background.png' },
                { id: 'barra_semillas', src: 'recursos/barra de semillas.png' },
                { id: 'sol_ui', src: 'recursos/sol.png' },
                { id: 'pala', src: 'recursos/pala.png' },
                { id: 'envoltura', src: 'recursos/envoltura de semilla.png' },
                { id: 'semilla_girasol', src: 'recursos/semilla de girasol.png' },
                { id: 'semilla_lanza_guisantes', src: 'recursos/semilla de lanza guisantes.png' },
                { id: 'semilla_nuez', src: 'recursos/semilla de nuez.png' },
                { id: 'semilla_cereza', src: 'recursos/semilla de cereza.png' },
                { id: 'cortacesped', src: 'recursos/cortacesped.png' }
            ]
        };

        // Carga de recursos
        let loadedCount = 0;
        function loadResources() {
            resources.toLoad.forEach(res => {
                const img = new Image();
                img.src = res.src;
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === resources.toLoad.length) {
                        init();
                    }
                };
                resources.images[res.id] = img;
            });
        }

        function init() {
            console.log("Recursos cargados. Iniciando...");
            loop();
        }

        function loop() {
            updateGame();
            render();
            requestAnimationFrame(loop);
        }

        // --- [INICIO TAREA 1.3] ---
        // TAREA 1.3: Entidades Pasivas (Sun, Pea, Lawnmower)

        // Clase Sun: Sol que cae desde arriba
        class Sun {
            constructor(x, y, targetY = null) {
                this.x = x;
                this.y = y;
                this.targetY = targetY || (Math.random() * 400 + 300); // Punto aleatorio donde se detiene
                this.falling = true;
                this.speed = 1.5; // Velocidad de caída
                this.radius = 30; // Radio para colisión
            }

            update() {
                if (this.falling) {
                    this.y += this.speed;
                    // Se detiene al alcanzar targetY
                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.falling = false;
                    }
                }
            }

            draw(ctx) {
                // Dibujar un círculo amarillo brillante como sol
                ctx.save();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                // Contorno más brillante
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.restore();
            }

            // Método vacío para recolección (se implementará en Lote 2)
            collect() {
                // TODO: Implementar en Lote 2
            }
        }

        // Clase Pea: Proyectil que viaja hacia la derecha
        class Pea {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 8; // Velocidad constante hacia la derecha
                this.radius = 10; // Radio para colisión
            }

            update() {
                this.x += this.speed;
            }

            draw(ctx) {
                // Dibujar un círculo verde como guisante
                ctx.save();
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                // Añadir brillo
                ctx.fillStyle = '#90EE90';
                ctx.beginPath();
                ctx.arc(this.x - 3, this.y - 3, this.radius / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Verificar si está fuera de pantalla
            isOffScreen() {
                return this.x > canvas.width + this.radius;
            }
        }

        // Clase Lawnmower: Cortacésped que se desplaza a alta velocidad
        class Lawnmower {
            constructor(x, y, row) {
                this.x = x;
                this.y = y;
                this.row = row; // Fila en la que está
                this.active = false;
                this.speed = 15; // Alta velocidad cuando se activa
            }

            update() {
                if (this.active) {
                    this.x += this.speed;
                }
            }

            draw(ctx) {
                // Dibujar un rectángulo rojo como cortacésped
                ctx.save();
                ctx.fillStyle = this.active ? '#FF0000' : '#8B0000';
                ctx.fillRect(this.x - 20, this.y - 15, 40, 30);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 20, this.y - 15, 40, 30);
                ctx.restore();
            }

            // Activar el cortacésped
            activate() {
                this.active = true;
            }

            // Verificar si está fuera de pantalla
            isOffScreen() {
                return this.x > canvas.width + 50;
            }
        }

        // Función de actualización del juego
        function updateGame() {
            frames++;

            // Actualizar todas las entidades
            entities.suns.forEach(sun => sun.update());
            entities.peas.forEach(pea => pea.update());
            entities.lawnmowers.forEach(lawnmower => lawnmower.update());

            // Limpiar entidades fuera de pantalla
            entities.peas = entities.peas.filter(pea => !pea.isOffScreen());
            entities.lawnmowers = entities.lawnmowers.filter(lawnmower => !lawnmower.isOffScreen());

            // DUMMY TRIGGER PARA TESTING - Task 1.3
            // Instanciar automáticamente un Sun cayendo y un Pea cruzando cada 120 frames
            if (frames % 120 === 0) {
                // Crear un sol cayendo desde una posición aleatoria en X
                const randomX = Math.random() * (canvas.width - 200) + 100;
                entities.suns.push(new Sun(randomX, 50));

                // Crear un guisante desde el lado izquierdo en una posición Y aleatoria
                const randomY = Math.random() * (CONFIG.grid.endY - CONFIG.grid.startY) + CONFIG.grid.startY;
                entities.peas.push(new Pea(100, randomY));
            }
        }

        // --- [FIN TAREA 1.3] ---

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Background
            ctx.drawImage(resources.images.background, 0, 0);

            // 2. Grid (Lineas rojas)
            drawGrid();

            // 3. Entidades (suns, peas) - TAREA 1.3
            entities.suns.forEach(sun => sun.draw(ctx));
            entities.peas.forEach(pea => pea.draw(ctx));
            entities.lawnmowers.forEach(lawnmower => lawnmower.draw(ctx));

            // 4. Cortacesped estáticos
            drawLawnmowers();

            // 5. Barra de semillas y UI
            drawUI();
        }

        function drawGrid() {
            ctx.save();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;

            const g = CONFIG.grid;
            const width = g.endX - g.startX;
            const height = g.endY - g.startY;
            const cellW = width / g.cols;
            const cellH = height / g.rows;

            // Dibujar rectángulo exterior
            // ctx.strokeRect(g.startX, g.startY, width, height);

            // Lineas verticales
            for (let i = 0; i <= g.cols; i++) {
                const x = g.startX + i * cellW;
                ctx.beginPath();
                ctx.moveTo(x, g.startY);
                ctx.lineTo(x, g.endY);
                ctx.stroke();
            }

            // Lineas horizontales
            for (let i = 0; i <= g.rows; i++) {
                const y = g.startY + i * cellH;
                ctx.beginPath();
                ctx.moveTo(g.startX, y);
                ctx.lineTo(g.endX, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawLawnmowers() {
            const g = CONFIG.grid;
            const height = g.endY - g.startY;
            const cellH = height / g.rows;
            const img = resources.images.cortacesped;

            for (let i = 0; i < g.rows; i++) {
                // Centrar verticalmente en la fila
                const rowCenterY = g.startY + i * cellH + (cellH / 2);
                // Ajustar Y para que el centro de la imagen coincida con el centro de la fila?
                // El prompt dice: "Los hitbox estarán en el centro de las animaciones."
                // Pero para dibujo estático, usualmente dibujamos top-left de la imagen.
                // Asumiremos que se dibuja centrado verticalmente.
                const y = rowCenterY - (img.height / 2); 
                
                ctx.drawImage(img, CONFIG.lawnmower.x, y);
            }
        }

        function drawUI() {
            const ui = CONFIG.ui;
            
            // Barra de semillas (fondo)
            ctx.drawImage(resources.images.barra_semillas, ui.seedBarPos.x, ui.seedBarPos.y);

            // Sol UI
            const sunCenter = (ui.sunRange.start + ui.sunRange.end) / 2;
            const sunImg = resources.images.sol_ui;
            // "Las imagenes de 'sol' y 'pala' de la barra de semillas tendrán una posición en 'y' de 0."
            ctx.drawImage(sunImg, sunCenter - (sunImg.width / 2), ui.positions.sunIconY);

            // Texto Soles
            ctx.fillStyle = 'black'; // Asumo negro o visible
            ctx.font = `${ui.text.sunSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(state.suns, sunCenter, ui.text.sunY);

            // Semillas
            let currentX = ui.seedRange.start;
            const envImg = resources.images.envoltura;
            
            state.seeds.forEach(seed => {
                // Envoltura
                // "Las semillas que estaran apiladas a la izquierda de su rango."
                // "Ancho de la entidad semilla será el ancho de la envoltura de semilla."
                
                // Dibujar envoltura
                ctx.drawImage(envImg, currentX, ui.positions.seedPacketY);
                
                // Dibujar imagen de la planta
                // "Las imagenes de semilla tendrán una altura de 0."
                let plantImg;
                if(seed.name === 'girasol') plantImg = resources.images.semilla_girasol;
                else if(seed.name === 'lanzaguisantes') plantImg = resources.images.semilla_lanza_guisantes;
                else if(seed.name === 'nuez') plantImg = resources.images.semilla_nuez;
                else if(seed.name === 'cereza') plantImg = resources.images.semilla_cereza;

                if (plantImg) {
                    // Centrar horizontalmente en la envoltura
                    const centerX = currentX + (envImg.width / 2);
                    const drawX = centerX - (plantImg.width / 2);
                    ctx.drawImage(plantImg, drawX, ui.positions.seedImageY);
                }

                // Costo
                ctx.fillStyle = 'black';
                ctx.font = `${ui.text.seedCostSize}px Arial`;
                ctx.textAlign = 'center';
                // Centrado en la envoltura
                const centerX = currentX + (envImg.width / 2);
                ctx.fillText(seed.cost, centerX, ui.text.seedCostY);

                // Avanzar X
                currentX += envImg.width;
            });

            // Pala
            const shovelCenter = (ui.shovelRange.start + ui.shovelRange.end) / 2;
            const shovelImg = resources.images.pala;
            ctx.drawImage(shovelImg, shovelCenter - (shovelImg.width / 2), ui.positions.shovelY);
        }

        // Iniciar
        loadResources();

    </script>
</body>
</html>