<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plants vs. Zombies - IA Agents</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="1636" height="1332"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const tintCanvas = document.createElement('canvas');
    const tintCtx = tintCanvas.getContext('2d');

    // Configuración de la Grid
    const GRID_START_X = 90;
    const GRID_START_Y = 280;
    const GRID_END_X = 1577;
    const GRID_END_Y = 1260;
    const COLS = 9;
    const ROWS = 5;
    const CELL_WIDTH = (GRID_END_X - GRID_START_X) / COLS;
    const CELL_HEIGHT = (GRID_END_Y - GRID_START_Y) / ROWS;
    
    // Variables Globales del Motor
    let frames = 0;
    let isPaused = false;
    let isDebug = false;
    let mouseX = 0;
    let mouseY = 0;
    
    // Arrays de Entidades
    let suns = [];
    let plants = [];
    let zombies = [];
    let peas = [];
    let particles = [];
    let floatingTexts = [];
    const lawnmowers = [];
    
    // Sistema de Hordas
    const LEVEL_CONFIG = { totalZombies: 40, horde1Threshold: 20, horde2Threshold: 38, baseSpawnRate: 350 };
    let zombiesSpawned = 0;

    // Recursos
    const imageSources = {
        background: 'recursos/background.png',
        barraSemillas: 'recursos/barra de semillas.png',
        sol: 'recursos/sol.png', 
        pala: 'recursos/pala.png',
        envoltura: 'recursos/envoltura de semilla.png',
        semillaGirasol: 'recursos/semilla de girasol.png',
        semillaGuisante: 'recursos/semilla de lanza guisantes.png',
        semillaNuez: 'recursos/semilla de nuez.png',
        cortacesped: 'recursos/cortacesped.png',
        guisante: 'recursos/guisante.png'
    };

    // Frames de animación del sol (carga dinámica)
    const sunFrames = [];
    const SUN_TOTAL_FRAMES = 192;
    let sunFramesLoaded = 0;

    const images = {};
    let imagesLoaded = 0;
    const totalImages = Object.keys(imageSources).length;

    // Datos de Semillas
    const seeds = [
        { name: 'girasol', imageKey: 'semillaGirasol', cost: 50, cooldown: 450, timer: 0 },
        { name: 'guisante', imageKey: 'semillaGuisante', cost: 100, cooldown: 450, timer: 0 },
        { name: 'nuez', imageKey: 'semillaNuez', cost: 50, cooldown: 1800, timer: 0 }
    ];

    // Estado del juego UI
    let sunAmount = 50; 
    const sunRange = { min: 10, max: 200 };
    const seedRange = { min: 200, max: 1110 };
    const shovelRange = { min: 1110, max: 1237 };
    
    let selectedSeed = null;
    let isShovelActive = false;
    let gridState = Array.from({ length: COLS }, () => Array(ROWS).fill(null));

    // ==========================================
    // 1. CLASES DE ENTIDADES (Agentes inyectan aquí)
    // ==========================================
    
    // --- [INICIO_ZONA_CLASE_SUN_1.1] ---
    class Sun {
        constructor(x, y, isFalling = true) {
            this.x = x;
            this.y = y;
            this.isFalling = isFalling;
            this.finalY = isFalling ? y + Math.random() * 300 + 200 : y;
            this.fallSpeed = 1.5;
            this.isCollecting = false;
            this.targetX = 105;
            this.targetY = 100;
            this.frame = Math.floor(Math.random() * SUN_TOTAL_FRAMES);
            this.animSpeed = 2;
            this.width = 0;
            this.height = 0;
            this.markedForDeletion = false;
        }

        update() {
            // Animación
            if (frames % this.animSpeed === 0) {
                this.frame = (this.frame + 1) % SUN_TOTAL_FRAMES;
            }

            if (this.isCollecting) {
                // Lerp hacia la UI
                this.x += (this.targetX - this.x) * 0.15;
                this.y += (this.targetY - this.y) * 0.15;

                // Llegó al destino
                if (Math.abs(this.x - this.targetX) < 5 && Math.abs(this.y - this.targetY) < 5) {
                    sunAmount += 25;
                    
                    // FloatingText dorado
                    floatingTexts.push(new FloatingText('+25', this.targetX, this.targetY, '#FFD700'));
                    
                    // Partículas doradas
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(this.targetX, this.targetY, '#FFD700', 'spark'));
                        particles.push(new Particle(this.targetX, this.targetY, '#FFFF00', 'circle'));
                    }
                    
                    this.markedForDeletion = true;
                }
            } else if (this.isFalling) {
                // Caída
                if (this.y < this.finalY) {
                    this.y += this.fallSpeed;
                } else {
                    this.y = this.finalY;
                    this.isFalling = false;
                }
            }
        }

        draw() {
            if (sunFrames[this.frame]) {
                const img = sunFrames[this.frame];
                this.width = img.naturalWidth * 0.5;
                this.height = img.naturalHeight * 0.5;
                const drawX = this.x - this.width / 2;
                const drawY = this.y - this.height / 2;
                ctx.drawImage(img, drawX, drawY, this.width, this.height);
            }
        }

        isClicked(mx, my) {
            const halfW = this.width / 2;
            const halfH = this.height / 2;
            return mx >= this.x - halfW && mx <= this.x + halfW &&
                   my >= this.y - halfH && my <= this.y + halfH;
        }
    }

    class FloatingText {
        constructor(text, x, y, color = '#FFD700') {
            this.text = text;
            this.x = x;
            this.y = y;
            this.color = color;
            this.alpha = 1;
            this.velocityY = -2;
            this.markedForDeletion = false;
        }

        update() {
            this.y += this.velocityY;
            this.alpha -= 0.02;
            if (this.alpha <= 0) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = this.color;
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, type = 'circle') {
            this.x = x;
            this.y = y;
            this.color = color;
            this.type = type;
            this.size = Math.random() * 6 + 3;
            this.velocityX = (Math.random() - 0.5) * 8;
            this.velocityY = (Math.random() - 0.5) * 8 - 2;
            this.gravity = 0.15;
            this.alpha = 1;
            this.markedForDeletion = false;
        }

        update() {
            this.x += this.velocityX;
            this.y += this.velocityY;
            this.velocityY += this.gravity;
            this.alpha -= 0.03;
            if (this.alpha <= 0) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            if (this.type === 'spark') {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.size);
                ctx.lineTo(this.x + this.size * 0.3, this.y);
                ctx.lineTo(this.x, this.y + this.size);
                ctx.lineTo(this.x - this.size * 0.3, this.y);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
    }

    function spawnSun(x, y, isFalling = true) {
        suns.push(new Sun(x, y, isFalling));
    }

    function loadSunFrames() {
        for (let i = 0; i < SUN_TOTAL_FRAMES; i++) {
            const img = new Image();
            const frameNum = String(i).padStart(3, '0');
            img.src = `recursos/sol/sol${frameNum}.png`;
            img.onload = () => sunFramesLoaded++;
            sunFrames.push(img);
        }
    }
    // --- [FIN_ZONA_CLASE_SUN_1.1] ---

    // --- [INICIO_ZONA_CLASE_PEA_2.2] ---
    class Pea {
        constructor(x, y, row) {
            this.x = x;
            this.y = y;
            this.row = row;
            this.speed = 5;
            this.damage = 20;
            this.width = 0;
            this.height = 0;
            this.markedForDeletion = false;
        }

        update() {
            this.x += this.speed;

            // Marcar para eliminación si sale del canvas
            if (this.x > canvas.width) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            if (images.guisante) {
                const img = images.guisante;
                this.width = img.width;
                this.height = img.height;
                ctx.drawImage(img, this.x - this.width / 2, this.y - this.height / 2);
            }
        }
    }

    function spawnPea(x, y, row) {
        peas.push(new Pea(x, y, row));
    }
    // --- [FIN_ZONA_CLASE_PEA_2.2] ---

    // --- [INICIO_ZONA_CLASE_ZOMBIE_2.1] ---
    const zombieAnimations = {
        walk: { frames: [], totalFrames: 46, scale: 0.35, path: 'recursos/zombie caminata/zombie caminata', ext: '.png', padZeros: 2 },
        eat: { frames: [], totalFrames: 36, scale: 0.35, path: 'recursos/zombie come/zombie come', ext: '.png', padZeros: 2 },
        die: { frames: [], totalFrames: 50, scale: 0.35, path: 'recursos/zombie perdurbador cae/zombie perdurbador cae', ext: '.png', padZeros: 2 }
    };
    let zombieAnimsLoaded = 0;

    class Zombie {
        constructor(row = null) {
            this.row = row !== null ? row : Math.floor(Math.random() * ROWS);
            this.x = GRID_END_X + 100;
            this.y = GRID_START_Y + (this.row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            this.state = 'walk';
            this.speed = 0.3;
            this.frame = 0;
            this.animSpeed = 2;
            this.hp = 100;
            this.maxHp = 100;
            this.damage = 10;
            this.attackCooldown = 30; // Frames entre ataques
            this.attackTimer = 0;
            this.flashTimer = 0;
            this.fadeTimer = 0;
            this.targetPlant = null;
            this.markedForDeletion = false;
        }

        update() {
            // Animación
            if (frames % this.animSpeed === 0) {
                const animData = zombieAnimations[this.state];
                if (animData) {
                    if (this.state === 'die' && this.frame >= animData.totalFrames - 1) {
                        // Mantener en el último frame
                        this.frame = animData.totalFrames - 1;
                    } else {
                        this.frame = (this.frame + 1) % animData.totalFrames;
                    }
                }
            }

            // Decrementar flash timer
            if (this.flashTimer > 0) {
                this.flashTimer--;
            }

            // Estados
            if (this.state === 'walk') {
                // Buscar planta en la misma fila para comer
                let closestPlant = null;
                let minDistance = Infinity;

                for (const plant of plants) {
                    if (plant.row === this.row && plant.x < this.x) {
                        const dist = this.x - plant.x;
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestPlant = plant;
                        }
                    }
                }

                // Si hay una planta cerca (menos de 60px), cambiar a estado eat
                if (closestPlant && minDistance < 60) {
                    this.state = 'eat';
                    this.targetPlant = closestPlant;
                    this.frame = 0;
                } else {
                    // Seguir caminando
                    this.x -= this.speed;
                }
            } else if (this.state === 'eat') {
                // Atacar la planta objetivo
                if (this.targetPlant && !this.targetPlant.markedForDeletion) {
                    this.attackTimer++;
                    if (this.attackTimer >= this.attackCooldown) {
                        this.targetPlant.takeDamage(this.damage);
                        this.attackTimer = 0;
                        
                        // Sonido de comer (aleatorio entre 3 sonidos)
                        const eatSound = Math.floor(Math.random() * 3) + 1;
                        new Audio(`recursos/sonidos/Zombi come ${eatSound}.wav`).play();
                    }
                } else {
                    // La planta fue destruida, volver a caminar
                    this.state = 'walk';
                    this.targetPlant = null;
                    this.attackTimer = 0;
                    this.frame = 0;
                }
            } else if (this.state === 'die') {
                // Incrementar fade timer
                this.fadeTimer++;
                if (this.fadeTimer >= 45) {
                    this.markedForDeletion = true;
                }
            }

            // Marcar para eliminación si HP <= 0 y no está en estado die
            if (this.hp <= 0 && this.state !== 'die') {
                this.state = 'die';
                this.frame = 0;
                this.fadeTimer = 0;
                
                // Generar partículas moradas
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(this.x, this.y, '#663399', 'circle'));
                    particles.push(new Particle(this.x, this.y, '#4B0082', 'spark'));
                }
            }
        }

        draw() {
            const animData = zombieAnimations[this.state];
            if (animData && animData.frames[this.frame]) {
                const img = animData.frames[this.frame];
                const scale = animData.scale;
                const width = img.naturalWidth * scale;
                const height = img.naturalHeight * scale;
                const drawX = this.x - width / 2;
                const drawY = this.y - height / 2;

                ctx.save();
                
                // Aplicar fade si está muriendo
                if (this.state === 'die') {
                    ctx.globalAlpha = 1 - (this.fadeTimer / 45);
                }
                
                ctx.drawImage(img, drawX, drawY, width, height);

                // Flash blanco al recibir daño
                if (this.flashTimer > 0) {
                    tintCanvas.width = width;
                    tintCanvas.height = height;
                    tintCtx.drawImage(img, 0, 0, width, height);
                    tintCtx.globalCompositeOperation = 'source-in';
                    tintCtx.fillStyle = 'white';
                    tintCtx.fillRect(0, 0, width, height);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(tintCanvas, drawX, drawY);
                    ctx.restore();
                }
                
                ctx.restore();
            }
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.flashTimer = 4;
            
            // Generar FloatingText rojo con el daño
            floatingTexts.push(new FloatingText(`-${amount}`, this.x, this.y - 30, '#FF0000'));
        }
    }

    function loadZombieAnimations() {
        for (const animName in zombieAnimations) {
            const animData = zombieAnimations[animName];
            for (let i = 0; i < animData.totalFrames; i++) {
                const img = new Image();
                const pad = (animData.padZeros !== undefined) ? animData.padZeros : 2;
                const frameNum = String(i).padStart(pad, '0');
                img.src = `${animData.path}${frameNum}${animData.ext}`;
                img.onload = () => zombieAnimsLoaded++;
                animData.frames.push(img);
            }
        }
    }
    // --- [FIN_ZONA_CLASE_ZOMBIE_2.1] ---

    // --- [INICIO_ZONA_CLASE_PLANT_1.3] ---
    const plantAnimations = {
        girasol: { frames: [], totalFrames: 58, scale: 0.3, path: 'recursos/girasol perturbador/girasol perturbador', ext: '.png', padZeros: 2 },
        guisante: { frames: [], totalFrames: 31, scale: 0.35, path: 'recursos/lg reposo perturbador/lg reposo perturbador', ext: '.png', padZeros: 2 },
        lg_ataque: { frames: [], totalFrames: 46, scale: 0.35, path: 'recursos/lanza guisantes ataque/lanza guisantes ataque', ext: '.png', padZeros: 2 },
        nuez: { frames: [], totalFrames: 1, scale: 0.3, path: 'recursos/nuez/nuez', ext: '.png', padZeros: 0 }
    };
    let plantAnimsLoaded = 0;

    class Plant {
        constructor(type, col, row) {
            this.type = type;
            this.col = col;
            this.row = row;
            this.x = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
            this.y = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            this.frame = 0;
            this.animSpeed = 2;
            this.hp = 100;
            this.maxHp = 100;
            this.flashTimer = 0;
            this.markedForDeletion = false;
            this.currentAnim = type; // Animación actual
            this.hasFiredThisLoop = false; // Para disparar solo una vez por ciclo
        }

        update() {
            // Lógica especial para lanzaguisantes
            if (this.type === 'guisante') {
                // Detectar zombis en la misma fila a la derecha
                let hasZombieInRow = false;
                for (const zombie of zombies) {
                    if (zombie.row === this.row && zombie.x > this.x) {
                        hasZombieInRow = true;
                        break;
                    }
                }

                // Cambiar animación según la presencia de zombis
                if (hasZombieInRow && this.currentAnim !== 'lg_ataque') {
                    this.currentAnim = 'lg_ataque';
                    this.frame = 0;
                    this.hasFiredThisLoop = false;
                } else if (!hasZombieInRow && this.currentAnim === 'lg_ataque') {
                    this.currentAnim = 'guisante';
                    this.frame = 0;
                }
            }

            // Animación
            if (frames % this.animSpeed === 0) {
                const animData = plantAnimations[this.currentAnim];
                if (animData) {
                    const prevFrame = this.frame;
                    this.frame = (this.frame + 1) % animData.totalFrames;

                    // Disparar en el frame 27 de lg_ataque
                    if (this.currentAnim === 'lg_ataque' && this.frame === 27 && !this.hasFiredThisLoop) {
                        // Posición de la boca del lanzaguisantes (+40px según la tabla de referencia)
                        const peaY = this.y - 40;
                        spawnPea(this.x + 30, peaY, this.row);
                        
                        // Generar partículas de chispas amarillas en la boca
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(this.x + 30, peaY, '#FFFF00', 'spark'));
                            particles.push(new Particle(this.x + 30, peaY, '#ADFF2F', 'spark'));
                        }
                        
                        this.hasFiredThisLoop = true;
                    }

                    // Resetear flag al completar el ciclo
                    if (this.frame < prevFrame) {
                        this.hasFiredThisLoop = false;
                    }
                }
            }

            // Decrementar flash timer
            if (this.flashTimer > 0) {
                this.flashTimer--;
            }

            // Marcar para eliminación si HP <= 0
            if (this.hp <= 0) {
                this.markedForDeletion = true;
            }
        }

        draw() {
            const animData = plantAnimations[this.currentAnim];
            if (animData && animData.frames[this.frame]) {
                const img = animData.frames[this.frame];
                const scale = animData.scale;
                const width = img.naturalWidth * scale;
                const height = img.naturalHeight * scale;
                const drawX = this.x - width / 2;
                const drawY = this.y - height / 2;

                ctx.save();
                ctx.drawImage(img, drawX, drawY, width, height);

                // Flash blanco al recibir daño
                if (this.flashTimer > 0) {
                    tintCanvas.width = width;
                    tintCanvas.height = height;
                    tintCtx.drawImage(img, 0, 0, width, height);
                    tintCtx.globalCompositeOperation = 'source-in';
                    tintCtx.fillStyle = 'white';
                    tintCtx.fillRect(0, 0, width, height);
                    
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(tintCanvas, drawX, drawY);
                    ctx.restore();
                }
                ctx.restore();
            }
        }

        takeDamage(amount) {
            this.hp -= amount;
            this.flashTimer = 4;
            
            // Generar FloatingText rojo con el daño
            floatingTexts.push(new FloatingText(`-${amount}`, this.x, this.y - 30, '#FF0000'));
        }
    }

    function loadPlantAnimations() {
        for (const plantType in plantAnimations) {
            const animData = plantAnimations[plantType];
            for (let i = 0; i < animData.totalFrames; i++) {
                const img = new Image();
                const pad = (animData.padZeros !== undefined) ? animData.padZeros : 2;
                const frameNum = String(i).padStart(pad, '0');
                img.src = `${animData.path}${frameNum}${animData.ext}`;
                img.onload = () => plantAnimsLoaded++;
                animData.frames.push(img);
            }
        }
    }
    // --- [FIN_ZONA_CLASE_PLANT_1.3] ---

    // ==========================================
    // 2. INPUTS Y EVENTOS
    // ==========================================
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
    });

    canvas.addEventListener('mousedown', (e) => {
        if (isPaused) return;

        // --- [INICIO_ZONA_CLICK_SOLES_1.1] ---
        for (const sun of suns) {
            if (!sun.isCollecting && sun.isClicked(mouseX, mouseY)) {
                sun.isCollecting = true;
                new Audio('recursos/sonidos/Recoger sol 1.wav').play();
                break;
            }
        }
        // --- [FIN_ZONA_CLICK_SOLES_1.1] ---

        // --- [INICIO_ZONA_CLICK_PALA_3.1] ---
        // --- [FIN_ZONA_CLICK_PALA_3.1] ---

        // --- [INICIO_ZONA_CLICK_PLANTAR_1.3] ---
        // Lógica de plantado
        if (selectedSeed && mouseX >= GRID_START_X && mouseX < GRID_END_X && 
            mouseY >= GRID_START_Y && mouseY < GRID_END_Y) {
            
            const col = Math.floor((mouseX - GRID_START_X) / CELL_WIDTH);
            const row = Math.floor((mouseY - GRID_START_Y) / CELL_HEIGHT);
            
            // Verificar que la celda esté vacía
            if (!gridState[col][row]) {
                // Verificar soles suficientes y cooldown
                if (sunAmount >= selectedSeed.cost && selectedSeed.timer <= 0) {
                    // Descontar costo
                    sunAmount -= selectedSeed.cost;
                    
                    // Crear planta
                    const plant = new Plant(selectedSeed.name, col, row);
                    plants.push(plant);
                    gridState[col][row] = plant;
                    
                    // Reiniciar cooldown
                    selectedSeed.timer = selectedSeed.cooldown;
                    
                    // FloatingText rojo con el costo
                    const cellCenterX = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
                    const cellCenterY = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
                    floatingTexts.push(new FloatingText(`-${selectedSeed.cost}`, cellCenterX, cellCenterY - 50, '#FF0000'));
                    
                    // Sonido de plantar
                    new Audio('recursos/sonidos/Plantar.wav').play();
                    
                    // Partículas de tierra
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(cellCenterX, cellCenterY, '#8B4513', 'circle'));
                        particles.push(new Particle(cellCenterX, cellCenterY, '#A0522D', 'circle'));
                    }
                    
                    // Deseleccionar semilla
                    selectedSeed = null;
                }
            }
        }
        // --- [FIN_ZONA_CLICK_PLANTAR_1.3] ---

        // --- [INICIO_ZONA_CLICK_SEMILLAS_1.2] ---
        // Detectar clic en semillas de la barra superior
        if (mouseY >= 20 && mouseY <= 160) {
            // Verificar si el clic está en el rango de semillas
            if (mouseX >= seedRange.min && mouseX < seedRange.max) {
                let currentSeedX = seedRange.min;
                const envolturaWidth = images.envoltura ? images.envoltura.width : 0;
                
                // Calcular qué semilla fue clickeada
                for (let i = 0; i < seeds.length; i++) {
                    const seedEndX = currentSeedX + envolturaWidth;
                    if (mouseX >= currentSeedX && mouseX < seedEndX) {
                        // Seleccionar esta semilla
                        selectedSeed = seeds[i];
                        isShovelActive = false; // Desactivar pala si estaba activa
                        break;
                    }
                    currentSeedX += envolturaWidth;
                }
            }
        }
        // --- [FIN_ZONA_CLICK_SEMILLAS_1.2] ---
    });

    window.addEventListener('keydown', (e) => {
        // --- [INICIO_ZONA_TECLAS_DEBUG_3.2] ---
        // --- [FIN_ZONA_TECLAS_DEBUG_3.2] ---
    });

    // ==========================================
    // 3. INICIALIZACIÓN
    // ==========================================
    function init() {
        for (let i = 0; i < ROWS; i++) {
            lawnmowers.push({
                x: -70,
                y: GRID_START_Y + (i * CELL_HEIGHT) + (CELL_HEIGHT / 2) - 30,
                row: i,
                active: false
            });
        }
        
        loadImages();
    }

    function loadImages() {
        loadSunFrames();
        loadPlantAnimations();
        loadZombieAnimations();
        for (let key in imageSources) {
            const img = new Image();
            img.src = imageSources[key];
            img.onload = () => {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    console.log('Todas las imágenes cargadas. Iniciando juego.');
                    initGame();
                }
            };
            img.onerror = (e) => console.error('Error cargando imagen:', key, e);
            images[key] = img;
        }
    }

    function initGame() {
        // === [TRIGGER_TAREA_1.1] ===
        spawnSun(200, 300, false);
        spawnSun(400, 300, false);
        // === [FIN_TRIGGER_TAREA_1.1] ===

        // === [TRIGGER_TAREA_1.3] ===
        sunAmount = 5000;
        // === [FIN_TRIGGER_TAREA_1.3] ===

        // === [TRIGGER_TAREA_2.1] ===
        zombies.push(new Zombie());
        // === [FIN_TRIGGER_TAREA_2.1] ===

        // === [TRIGGER_TAREA_2.2] ===
        plants.push(new Plant('guisante', 0, 2));
        zombies.push(new Zombie(2));
        // === [FIN_TRIGGER_TAREA_2.2] ===

        // === [TRIGGER_TAREA_3.2] ===
        // === [FIN_TRIGGER_TAREA_3.2] ===

        // === [TRIGGER_TAREA_4.1] ===
        // === [FIN_TRIGGER_TAREA_4.1] ===

        requestAnimationFrame(gameLoop);
    }

    // ==========================================
    // 4. LÓGICA PRINCIPAL (UPDATE)
    // ==========================================
    function checkCollisions() {
        // --- [INICIO_ZONA_COLISIONES_2.3] ---
        // --- [FIN_ZONA_COLISIONES_2.3] ---
    }

    function updateGame() {
        // --- [INICIO_ZONA_UPDATE_ENTIDADES] ---
        // Update suns
        suns.forEach(sun => sun.update());
        suns = suns.filter(sun => !sun.markedForDeletion);

        // Update floating texts
        floatingTexts.forEach(ft => ft.update());
        floatingTexts = floatingTexts.filter(ft => !ft.markedForDeletion);

        // Update particles
        particles.forEach(p => p.update());
        particles = particles.filter(p => !p.markedForDeletion);

        // Update plants
        plants.forEach(plant => plant.update());
        plants = plants.filter(plant => {
            if (plant.markedForDeletion) {
                // Limpiar gridState
                gridState[plant.col][plant.row] = null;
                return false;
            }
            return true;
        });

        // Update seed cooldowns
        seeds.forEach(seed => {
            if (seed.timer > 0) {
                seed.timer--;
            }
        });

        // Update zombies
        zombies.forEach(zombie => zombie.update());
        zombies = zombies.filter(zombie => !zombie.markedForDeletion);

        // Update peas
        peas.forEach(pea => pea.update());
        peas = peas.filter(pea => !pea.markedForDeletion);
        // --- [FIN_ZONA_UPDATE_ENTIDADES] ---

        // === [TRIGGER_TAREA_3.3] ===
        // === [FIN_TRIGGER_TAREA_3.3] ===

        // --- [INICIO_ZONA_SPAWN_NORMAL_2.1] ---
        // --- [FIN_ZONA_SPAWN_NORMAL_2.1] ---

        // --- [INICIO_ZONA_SPAWN_HORDAS_4.2] ---
        // --- [FIN_ZONA_SPAWN_HORDAS_4.2] ---

        checkCollisions();
        frames++;
    }

    // ==========================================
    // 5. RENDERIZADO PRINCIPAL (DRAW)
    // ==========================================
    function gameLoop() {
        if (!isPaused) updateGame();
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (images.background) ctx.drawImage(images.background, 0, 0);

        drawGrid();

        // --- [INICIO_ZONA_DRAW_ENTIDADES] ---
        // Draw plants
        plants.forEach(plant => plant.draw());

        // Draw zombies
        zombies.forEach(zombie => zombie.draw());

        // Draw peas
        peas.forEach(pea => pea.draw());

        // Draw suns
        suns.forEach(sun => sun.draw());

        // Draw particles
        particles.forEach(p => p.draw());

        // Draw floating texts
        floatingTexts.forEach(ft => ft.draw());
        // --- [FIN_ZONA_DRAW_ENTIDADES] ---

        drawLawnmowers();

        // --- [INICIO_ZONA_DRAW_FANTASMA_1.2] ---
        // Dibujar planta fantasma si hay una semilla seleccionada
        if (selectedSeed && mouseX >= GRID_START_X && mouseX < GRID_END_X && 
            mouseY >= GRID_START_Y && mouseY < GRID_END_Y) {
            
            // Calcular la celda sobre la que está el mouse
            const col = Math.floor((mouseX - GRID_START_X) / CELL_WIDTH);
            const row = Math.floor((mouseY - GRID_START_Y) / CELL_HEIGHT);
            
            // Calcular el centro de la celda para hacer snap
            const cellCenterX = GRID_START_X + (col * CELL_WIDTH) + (CELL_WIDTH / 2);
            const cellCenterY = GRID_START_Y + (row * CELL_HEIGHT) + (CELL_HEIGHT / 2);
            
            // Dibujar la imagen de la semilla con transparencia como fantasma
            const animData = plantAnimations[selectedSeed.name];
            if (animData && animData.frames.length > 0 && animData.frames[0]) {
                const plantImg = animData.frames[0];
                const scale = animData.scale;
                const width = plantImg.naturalWidth * scale;
                const height = plantImg.naturalHeight * scale;

                ctx.save();
                ctx.globalAlpha = 0.5;
                const drawX = cellCenterX - (width / 2);
                const drawY = cellCenterY - (height / 2);
                ctx.drawImage(plantImg, drawX, drawY, width, height);
                ctx.restore();
            }
        }
        // --- [FIN_ZONA_DRAW_FANTASMA_1.2] ---

        drawUI();

        // --- [INICIO_ZONA_DRAW_COOLDOWN_3.1] ---
        // --- [FIN_ZONA_DRAW_COOLDOWN_3.1] ---

        // --- [INICIO_ZONA_DRAW_PROGRESO_3.3] ---
        // --- [FIN_ZONA_DRAW_PROGRESO_3.3] ---

        // --- [INICIO_ZONA_DRAW_DEBUG_3.2] ---
        // --- [FIN_ZONA_DRAW_DEBUG_3.2] ---

        requestAnimationFrame(gameLoop);
    }

    function drawGrid() {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i <= COLS; i++) {
            const x = GRID_START_X + (i * CELL_WIDTH);
            ctx.moveTo(x, GRID_START_Y);
            ctx.lineTo(x, GRID_END_Y);
        }
        for (let i = 0; i <= ROWS; i++) {
            const y = GRID_START_Y + (i * CELL_HEIGHT);
            ctx.moveTo(GRID_START_X, y);
            ctx.lineTo(GRID_END_X, y);
        }
        ctx.stroke();
    }

    function drawUI() {
        if (images.barraSemillas) ctx.drawImage(images.barraSemillas, 10, 10);

        const sunCenterX = (sunRange.min + sunRange.max) / 2;
        if (images.sol) {
            const solX = sunCenterX - (images.sol.width / 2);
            ctx.drawImage(images.sol, solX, 0);
        }
        
        ctx.font = '40px Arial';
        ctx.fillStyle = 'black';
        ctx.textAlign = 'center';
        ctx.fillText(sunAmount, sunCenterX, 195);

        const shovelCenterX = (shovelRange.min + shovelRange.max) / 2;
        if (images.pala) {
            const palaX = shovelCenterX - (images.pala.width / 2);
            ctx.drawImage(images.pala, palaX, 0);
        }

        let currentSeedX = seedRange.min;
        
        seeds.forEach(seed => {
            const envolturaImg = images.envoltura;
            const plantaImg = images[seed.imageKey];
            
            if (envolturaImg && plantaImg) {
                const seedWidth = envolturaImg.width; 
                ctx.drawImage(envolturaImg, currentSeedX, 20);
                
                const plantaX = currentSeedX + (seedWidth / 2) - (plantaImg.width / 2);
                ctx.drawImage(plantaImg, plantaX, 0);
                
                ctx.font = '25px Arial';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                const textX = currentSeedX + (seedWidth / 2);
                ctx.fillText(seed.cost, textX, 183);

                currentSeedX += seedWidth;
            }
        });
    }

    function drawLawnmowers() {
        lawnmowers.forEach(mower => {
            if (images.cortacesped) {
                const drawY = GRID_START_Y + (mower.row * CELL_HEIGHT) + (CELL_HEIGHT/2) - (images.cortacesped.height / 2);
                ctx.drawImage(images.cortacesped, mower.x, drawY);
            }
        });
    }

    init();

</script>
</body>
</html>